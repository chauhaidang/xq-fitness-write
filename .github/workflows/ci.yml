name: Build Test Publish Deploy

on:
  push:
    branches:
      - main
    paths:
      - 'src/**'
      - '.github/workflows/ci.yml'
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository_owner }}/xq-fitness-write-service
  GITHUB_OWNER: ${{ github.repository_owner }}
  SERVICE_NAME: write-service
  APP_ID: 7960143e-c80f-496d-9992-f24430bb77ff
  APP_NAME: xq-fitness
  GITHUB_ACTOR: ${{ github.actor }}
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  DO_TOKEN: ${{ secrets.DO_TOKEN }}

jobs:
  unit-tests:
    name: Run Tests
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          registry-url: 'https://npm.pkg.github.com/'
          scope: '@chauhaidang'

      - name: Install global tools
        run: |
          npm install -g @chauhaidang/xq-test-infra
          npm install -g @openapitools/openapi-generator-cli

      - name: build write-service
        run: |
          chmod +x ./build-write-service.sh
          ./build-write-service.sh

      - name: Generate write-service api client
        run: npm run generate:client

      - name: Install dependencies
        run: npm ci
      
      - name: Run unit tests
        run: npm run test:unit

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: |
            test/component/tsr/
            coverage/
          retention-days: 7

      - name: Upload coverage report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: coverage/lcov-report/
          retention-days: 7

  component-tests:
    name: Run Component Tests
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          registry-url: 'https://npm.pkg.github.com/'
          scope: '@chauhaidang'

      - name: Install global tools
        run: |
          npm install -g @chauhaidang/xq-test-infra
          npm install -g @openapitools/openapi-generator-cli

      - name: build write-service
        run: |
          chmod +x ./build-write-service.sh
          ./build-write-service.sh

      - name: Generate write-service api client
        run: npm run generate:client

      - name: Install dependencies
        run: npm ci
      
      - name: Start up environment
        run: xq-infra generate -f ./test-env && xq-infra up

      - name: Run component tests
        run: npm run test:component:ci

      - name: Stop environment
        if: always()
        run: xq-infra down
      
      - name: Present tsr
        if: success() || failure()
        working-directory: ./
        run: cat test/component/tsr/report.md >> $GITHUB_STEP_SUMMARY

  dockerize-and-deploy:
    name: Build and Push Docker Image
    needs: [unit-tests, component-tests]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        id: push
        with:
          context: ./
          file: Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            GITHUB_ACTOR=${{ github.actor }}
            GITHUB_TOKEN=${{ secrets.GITHUB_TOKEN }}

      - name: Install doctl and dependencies
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DO_TOKEN }}

      - name: Install additional dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq gettext-base
          # Install yq for YAML manipulation
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
     
      - name: Provision database
        id: provision-db
        env:
          REGION: 'sgp1'
          APP_NAME: 'xq-fitness'
          APP_DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
        run: |
          # Provision database (idempotent - safe to run multiple times)
          chmod +x scripts/provision-db.sh
          cd scripts/
          # Run provision-db.sh - it will create DB if needed or use existing
          # If user exists and password not provided, script will fail (expected)
          ./provision-db.sh 2>&1 | tee provision-output.log || {
            echo "⚠️  Provision script exited with error, checking if DB already exists..."
            # If script failed, try to get connection details from existing DB
          }
          
          # Get connection details by querying doctl (most reliable)
          DB_CLUSTER_NAME="${APP_NAME:-xq-fitness}-db"
          DB_CLUSTER_ID=$(doctl databases list --output json | jq -r '.[] | select(.name=="'"$DB_CLUSTER_NAME"'") | .id' | head -n1)
          
          if [ -z "$DB_CLUSTER_ID" ]; then
            echo "Error: Database cluster not found. Provision script may have failed."
            exit 1
          fi
          
          # Get connection details
          CONNECTION_JSON=$(doctl databases connection "$DB_CLUSTER_ID" --output json)
          
          # Handle both array and object formats (same logic as provision-db.sh)
          if echo "$CONNECTION_JSON" | jq -e 'type == "array"' >/dev/null 2>&1; then
            DB_HOST=$(echo "$CONNECTION_JSON" | jq -r '.[0].host // .[0].uri // empty')
            DB_PORT=$(echo "$CONNECTION_JSON" | jq -r '.[0].port // empty')
          else
            DB_HOST=$(echo "$CONNECTION_JSON" | jq -r '.host // .uri // empty')
            DB_PORT=$(echo "$CONNECTION_JSON" | jq -r '.port // empty')
          fi
          
          # If host is a URI, extract hostname from it
          if [[ "$DB_HOST" == *"@"* ]]; then
            DB_HOST=$(echo "$DB_HOST" | sed -E 's/.*@([^:]+).*/\1/')
          fi
          
          # Fallback: try to get connection string and parse it
          if [[ -z "$DB_HOST" ]] || [[ -z "$DB_PORT" ]]; then
            if echo "$CONNECTION_JSON" | jq -e 'type == "array"' >/dev/null 2>&1; then
              CONNECTION_STRING=$(echo "$CONNECTION_JSON" | jq -r '.[0].uri // .[0].connection_string // empty')
            else
              CONNECTION_STRING=$(echo "$CONNECTION_JSON" | jq -r '.uri // .connection_string // empty')
            fi
            if [[ -n "$CONNECTION_STRING" ]]; then
              DB_HOST=$(echo "$CONNECTION_STRING" | sed -E 's/.*@([^:]+):.*/\1/')
              DB_PORT=$(echo "$CONNECTION_STRING" | sed -E 's/.*:([0-9]+)\/.*/\1/')
            fi
          fi
          
          # Final fallback: extract from script output if still empty
          if [[ -z "$DB_HOST" ]] || [[ -z "$DB_PORT" ]]; then
            DB_HOST=$(grep -E "^  Host:" provision-output.log | awk '{print $2}' | tr -d '"' || echo "")
            DB_PORT=$(grep -E "^  Port:" provision-output.log | awk '{print $2}' | tr -d '"' || echo "")
          fi
          
          # Get database and user names (from script defaults or secrets)
          DB_NAME="${APP_DB_NAME:-xq_fitness}"
          DB_USER="${APP_DB_USER:-xq_app_user}"
          
          # Also try to extract from script output as fallback
          if [[ -z "$DB_NAME" ]]; then
            DB_NAME=$(grep -E "^  Database:" provision-output.log | awk '{print $2}' | tr -d '"' || echo "")
          fi
          if [[ -z "$DB_USER" ]]; then
            DB_USER=$(grep -E "^  User:" provision-output.log | awk '{print $2}' | tr -d '"' || echo "")
          fi
          
          # Use secrets as fallback
          DB_HOST="${DB_HOST:-${{ secrets.DB_HOST }}}"
          DB_PORT="${DB_PORT:-${{ secrets.DB_PORT }}}"
          DB_USER="${DB_USER:-${{ secrets.DB_USER }}}"
          DB_PASSWORD="${{ secrets.DB_PASSWORD }}"
          DB_NAME="${DB_NAME:-${{ secrets.DB_NAME }}}"
          
          if [ -z "$DB_HOST" ] || [ -z "$DB_PORT" ] || [ -z "$DB_USER" ] || [ -z "$DB_PASSWORD" ] || [ -z "$DB_NAME" ]; then
            echo "Error: Could not determine all database connection details"
            echo "DB_HOST: ${DB_HOST:-not set}"
            echo "DB_PORT: ${DB_PORT:-not set}"
            echo "DB_USER: ${DB_USER:-not set}"
            echo "DB_PASSWORD: ${DB_PASSWORD:+set (hidden)}"
            echo "DB_NAME: ${DB_NAME:-not set}"
            echo ""
            echo "Note: If this is the first run, ensure DB_PASSWORD secret is set after running provision-db.sh manually"
            exit 1
          fi
          
          # Output connection details for next step
          echo "db_host=$DB_HOST" >> $GITHUB_OUTPUT
          echo "db_port=$DB_PORT" >> $GITHUB_OUTPUT
          echo "db_user=$DB_USER" >> $GITHUB_OUTPUT
          echo "db_password=$DB_PASSWORD" >> $GITHUB_OUTPUT
          echo "db_name=$DB_NAME" >> $GITHUB_OUTPUT
          
          echo "✓ Database provisioned/verified"
          echo "  Host: $DB_HOST"
          echo "  Port: $DB_PORT"
          echo "  Database: $DB_NAME"
          echo "  User: $DB_USER"

      - name: Determine image tag
        id: image-tag
        run: |
          # Extract the latest tag from metadata (for main branch it will be 'latest')
          # For other branches, use branch name or sha
          if [ "${{ github.ref }}" == "refs/heads/main" ]; then
            echo "tag=latest" >> $GITHUB_OUTPUT
          else
            BRANCH_NAME=$(echo "${{ github.ref }}" | sed 's/refs\/heads\///')
            echo "tag=${BRANCH_NAME}-${GITHUB_SHA::8}" >> $GITHUB_OUTPUT
          fi

      - name: Render app spec
        id: render-spec
        env:
          APP_NAME: 'xq-fitness'
          REGION: 'sgp1'
          IMAGE_TAG: ${{ steps.image-tag.outputs.tag || 'latest' }}
          GITHUB_REGISTRY_CREDENTIALS: ${{ env.GITHUB_OWNER }}:${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}
          DB_HOST: ${{ steps.provision-db.outputs.db_host }}
          DB_PORT: ${{ steps.provision-db.outputs.db_port }}
          DB_USER: ${{ steps.provision-db.outputs.db_user }}
          DB_PASSWORD: ${{ steps.provision-db.outputs.db_password }}
          DB_NAME: ${{ steps.provision-db.outputs.db_name }}
        run: |
          # Export all required variables for envsubst
          export APP_NAME="${APP_NAME}"
          export REGION="${REGION}"
          export IMAGE_NAME="${IMAGE_NAME}"
          export IMAGE_TAG="${IMAGE_TAG:-latest}"
          export DB_HOST="${DB_HOST}"
          export DB_PORT="${DB_PORT}"
          export DB_USER="${DB_USER}"
          export DB_PASSWORD="${DB_PASSWORD}"
          export DB_NAME="${DB_NAME}"
          
          # Debug: show what will be substituted
          echo ">> Variables for substitution:"
          echo "  APP_NAME: $APP_NAME"
          echo "  REGION: $REGION"
          echo "  IMAGE_NAME: $IMAGE_NAME"
          echo "  IMAGE_TAG: $IMAGE_TAG"
          echo "  DB_HOST: $DB_HOST"
          echo "  DB_PORT: $DB_PORT"
          echo "  DB_USER: $DB_USER"
          echo "  DB_NAME: $DB_NAME"
          echo ""
          
          # Render .do/app.yaml from template
          envsubst < .do/app.yaml > .do/app.rendered.yaml
          
          echo "✓ Rendered app spec"
          echo "Preview (first 30 lines):"
          head -n 30 .do/app.rendered.yaml

      - name: Merge app spec with existing services
        id: merge-spec
        env:
          APP_NAME: 'xq-fitness'
          GITHUB_REGISTRY_CREDENTIALS: ${{ github.repository_owner }}:${{ secrets.GITHUB_TOKEN }}
          DB_PASSWORD: ${{ steps.provision-db.outputs.db_password }}
        run: |
          set -euo pipefail
          
          if [ ! -f .do/app.rendered.yaml ]; then
            echo "Error: Rendered app spec file not found" >&2
            exit 1
          fi
          
          # Merge rendered spec with existing app spec (preserves other services)
          chmod +x scripts/merge-app-spec.sh
          ./scripts/merge-app-spec.sh .do/app.rendered.yaml "$APP_NAME" .do/app.merged.yaml
          
          # Output merged spec file path
          echo "merged_spec_file=.do/app.merged.yaml" >> $GITHUB_OUTPUT
          echo "✓ Merged app spec: .do/app.merged.yaml"

      - name: Create or update App Platform app
        id: app-setup
        run: |
          set -euo pipefail
          
          MERGED_SPEC="${{ steps.merge-spec.outputs.merged_spec_file }}"
          
          if [ ! -f "$MERGED_SPEC" ]; then
            echo "Error: Merged spec file not found: $MERGED_SPEC" >&2
            exit 1
          fi
          
          # Update existing app
          echo "Updating existing app: $APP_ID"
          if ! doctl apps update "$APP_ID" --spec "$MERGED_SPEC" --output json >/dev/null 2>&1; then
            echo "Error updating app" >&2
            exit 1
          fi
          
          echo "✓ Updated app: $APP_ID"
          
          echo "app_id=$APP_ID" >> $GITHUB_OUTPUT

      - name: Deploy to App Platform
        uses: digitalocean/app_action/deploy@v2
        with:
          token: ${{ secrets.DO_TOKEN }}
          app_name: ${{ secrets.APP_NAME || 'xq-fitness' }}
          app_spec_location: ${{ steps.merge-spec.outputs.merged_spec_file }}
          print_deploy_logs: true
