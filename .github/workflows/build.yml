name: build and publish

on:
  push:
    branches:
      - main
    paths:
      - 'src/**'
      - 'build.yml'
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository_owner }}/xq-fitness-write-service
  GITHUB_OWNER: ${{ github.repository_owner }}
  SERVICE_NAME: write-service

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        id: push
        with:
          context: ./
          file: Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            GITHUB_TOKEN=${{ secrets.GITHUB_TOKEN }}

      - name: Install doctl and dependencies
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DO_TOKEN }}

      - name: Install additional dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq gettext-base
     
      - name: Provision database
        id: provision-db
        env:
          DO_TOKEN: ${{ secrets.DO_TOKEN }}
          REGION: ${{ secrets.REGION || 'sgp1' }}
          APP_NAME: ${{ secrets.APP_NAME || 'xq-fitness' }}
          APP_DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
        run: |
          # Provision database (idempotent - safe to run multiple times)
          chmod +x deploy/digitalocean/provision-db.sh
          cd deploy/digitalocean
          
          # Run provision-db.sh - it will create DB if needed or use existing
          # If user exists and password not provided, script will fail (expected)
          ./provision-db.sh 2>&1 | tee provision-output.log || {
            echo "⚠️  Provision script exited with error, checking if DB already exists..."
            # If script failed, try to get connection details from existing DB
          }
          
          # Get connection details by querying doctl (most reliable)
          DB_CLUSTER_NAME="${APP_NAME:-xq-fitness}-db"
          DB_CLUSTER_ID=$(doctl databases list --output json | jq -r '.[] | select(.name=="'"$DB_CLUSTER_NAME"'") | .id' | head -n1)
          
          if [ -z "$DB_CLUSTER_ID" ]; then
            echo "Error: Database cluster not found. Provision script may have failed."
            exit 1
          fi
          
          # Get connection details
          CONNECTION_JSON=$(doctl databases connection "$DB_CLUSTER_ID" --output json)
          
          # Handle both array and object formats (same logic as provision-db.sh)
          if echo "$CONNECTION_JSON" | jq -e 'type == "array"' >/dev/null 2>&1; then
            DB_HOST=$(echo "$CONNECTION_JSON" | jq -r '.[0].host // .[0].uri // empty')
            DB_PORT=$(echo "$CONNECTION_JSON" | jq -r '.[0].port // empty')
          else
            DB_HOST=$(echo "$CONNECTION_JSON" | jq -r '.host // .uri // empty')
            DB_PORT=$(echo "$CONNECTION_JSON" | jq -r '.port // empty')
          fi
          
          # If host is a URI, extract hostname from it
          if [[ "$DB_HOST" == *"@"* ]]; then
            DB_HOST=$(echo "$DB_HOST" | sed -E 's/.*@([^:]+).*/\1/')
          fi
          
          # Fallback: try to get connection string and parse it
          if [[ -z "$DB_HOST" ]] || [[ -z "$DB_PORT" ]]; then
            if echo "$CONNECTION_JSON" | jq -e 'type == "array"' >/dev/null 2>&1; then
              CONNECTION_STRING=$(echo "$CONNECTION_JSON" | jq -r '.[0].uri // .[0].connection_string // empty')
            else
              CONNECTION_STRING=$(echo "$CONNECTION_JSON" | jq -r '.uri // .connection_string // empty')
            fi
            if [[ -n "$CONNECTION_STRING" ]]; then
              DB_HOST=$(echo "$CONNECTION_STRING" | sed -E 's/.*@([^:]+):.*/\1/')
              DB_PORT=$(echo "$CONNECTION_STRING" | sed -E 's/.*:([0-9]+)\/.*/\1/')
            fi
          fi
          
          # Final fallback: extract from script output if still empty
          if [[ -z "$DB_HOST" ]] || [[ -z "$DB_PORT" ]]; then
            DB_HOST=$(grep -E "^  Host:" provision-output.log | awk '{print $2}' | tr -d '"' || echo "")
            DB_PORT=$(grep -E "^  Port:" provision-output.log | awk '{print $2}' | tr -d '"' || echo "")
          fi
          
          # Get database and user names (from script defaults or secrets)
          DB_NAME="${APP_DB_NAME:-xq_fitness}"
          DB_USER="${APP_DB_USER:-xq_app_user}"
          
          # Also try to extract from script output as fallback
          if [[ -z "$DB_NAME" ]]; then
            DB_NAME=$(grep -E "^  Database:" provision-output.log | awk '{print $2}' | tr -d '"' || echo "")
          fi
          if [[ -z "$DB_USER" ]]; then
            DB_USER=$(grep -E "^  User:" provision-output.log | awk '{print $2}' | tr -d '"' || echo "")
          fi
          
          # Use secrets as fallback
          DB_HOST="${DB_HOST:-${{ secrets.DB_HOST }}}"
          DB_PORT="${DB_PORT:-${{ secrets.DB_PORT }}}"
          DB_USER="${DB_USER:-${{ secrets.DB_USER }}}"
          DB_PASSWORD="${{ secrets.DB_PASSWORD }}"
          DB_NAME="${DB_NAME:-${{ secrets.DB_NAME }}}"
          
          if [ -z "$DB_HOST" ] || [ -z "$DB_PORT" ] || [ -z "$DB_USER" ] || [ -z "$DB_PASSWORD" ] || [ -z "$DB_NAME" ]; then
            echo "Error: Could not determine all database connection details"
            echo "DB_HOST: ${DB_HOST:-not set}"
            echo "DB_PORT: ${DB_PORT:-not set}"
            echo "DB_USER: ${DB_USER:-not set}"
            echo "DB_PASSWORD: ${DB_PASSWORD:+set (hidden)}"
            echo "DB_NAME: ${DB_NAME:-not set}"
            echo ""
            echo "Note: If this is the first run, ensure DB_PASSWORD secret is set after running provision-db.sh manually"
            exit 1
          fi
          
          # Output connection details for next step
          echo "db_host=$DB_HOST" >> $GITHUB_OUTPUT
          echo "db_port=$DB_PORT" >> $GITHUB_OUTPUT
          echo "db_user=$DB_USER" >> $GITHUB_OUTPUT
          echo "db_password=$DB_PASSWORD" >> $GITHUB_OUTPUT
          echo "db_name=$DB_NAME" >> $GITHUB_OUTPUT
          
          echo "✓ Database provisioned/verified"
          echo "  Host: $DB_HOST"
          echo "  Port: $DB_PORT"
          echo "  Database: $DB_NAME"
          echo "  User: $DB_USER"

      - name: Determine image tag
        id: image-tag
        run: |
          # Extract the latest tag from metadata (for main branch it will be 'latest')
          # For other branches, use branch name or sha
          if [ "${{ github.ref }}" == "refs/heads/main" ]; then
            echo "tag=latest" >> $GITHUB_OUTPUT
          else
            BRANCH_NAME=$(echo "${{ github.ref }}" | sed 's/refs\/heads\///')
            echo "tag=${BRANCH_NAME}-${GITHUB_SHA::8}" >> $GITHUB_OUTPUT
          fi

      - name: Render app spec
        id: render-spec
        env:
          APP_NAME: ${{ secrets.APP_NAME || 'xq-fitness' }}
          REGION: ${{ secrets.REGION || 'sgp1' }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          IMAGE_TAG: ${{ steps.image-tag.outputs.tag }}
          GITHUB_REGISTRY_CREDENTIALS: ${{ env.GITHUB_OWNER }}:${{ secrets.GITHUB_PAT || secrets.GITHUB_TOKEN }}
          DB_HOST: ${{ steps.provision-db.outputs.db_host }}
          DB_PORT: ${{ steps.provision-db.outputs.db_port }}
          DB_USER: ${{ steps.provision-db.outputs.db_user }}
          DB_PASSWORD: ${{ steps.provision-db.outputs.db_password }}
          DB_NAME: ${{ steps.provision-db.outputs.db_name }}
        run: |
          # Render .do/app.yaml from template
          envsubst < .do/app.yaml > .do/app.rendered.yaml
          
          # Remove empty registry_credentials if needed
          if grep -q 'registry_credentials: ""' .do/app.rendered.yaml; then
            sed -i '/registry_credentials: ""$/d' .do/app.rendered.yaml
          fi
          
          echo "✓ Rendered app spec"
          echo "Preview (first 30 lines):"
          head -n 30 .do/app.rendered.yaml

      - name: Create or update App Platform app
        id: app-setup
        env:
          APP_NAME: ${{ secrets.APP_NAME || 'xq-fitness' }}
        run: |
          # Validate rendered spec exists
          if [ ! -f .do/app.rendered.yaml ]; then
            echo "Error: Rendered app spec file not found" >&2
            exit 1
          fi
          
          # Show rendered spec for debugging
          echo ">> Rendered app spec:"
          cat .do/app.rendered.yaml
          echo ""
          
          # Validate spec
          echo ">> Validating app spec..."
          if doctl apps spec validate .do/app.rendered.yaml 2>&1; then
            echo "✓ Spec validation passed"
          else
            echo "⚠️  Spec validation failed, but continuing..."
          fi
          
          # Get existing app ID if it exists
          APP_ID=$(doctl apps list --output json 2>/dev/null | jq -r '.[] | select(.spec.name=="'"$APP_NAME"'") | .id' | head -n1 || echo "")
          
          if [ -z "$APP_ID" ]; then
            echo "Creating new app..."
            if ! CREATE_RESPONSE=$(doctl apps create --spec .do/app.rendered.yaml --output json 2>&1); then
              echo "Error creating app:" >&2
              echo "$CREATE_RESPONSE" >&2
              echo "" >&2
              echo "Rendered spec file:" >&2
              cat .do/app.rendered.yaml >&2
              exit 1
            fi
            APP_ID=$(echo "$CREATE_RESPONSE" | jq -r '.app.id // .id // empty')
            if [ -z "$APP_ID" ]; then
              echo "Error: Could not extract app ID from create response:" >&2
              echo "$CREATE_RESPONSE" >&2
              exit 1
            fi
            echo "Created app: $APP_ID"
          else
            echo "Updating existing app: $APP_ID"
            if ! UPDATE_RESPONSE=$(doctl apps update "$APP_ID" --spec .do/app.rendered.yaml --output json 2>&1); then
              echo "Error updating app:" >&2
              echo "$UPDATE_RESPONSE" >&2
              echo "" >&2
              echo "Rendered spec file:" >&2
              cat .do/app.rendered.yaml >&2
              exit 1
            fi
            echo "Updated app: $APP_ID"
          fi
          
          echo "app_id=$APP_ID" >> $GITHUB_OUTPUT
          echo "✓ App ID: $APP_ID"

      - name: Deploy to App Platform
        uses: digitalocean/app_action/deploy@v2
        with:
          token: ${{ secrets.DO_TOKEN }}
          app_id: ${{ steps.app-setup.outputs.app_id }}