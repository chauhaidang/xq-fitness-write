name: Deploy to DigitalOcean

on:
  push:
    branches:
      - main
    paths:
      - 'src/**'
      - 'Dockerfile'
      - '.github/workflows/deploy-docr.yml'
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Image tag from GitHub Container Registry (default: latest)'
        required: false
        default: 'latest'
      deploy:
        description: 'Deploy to App Platform'
        required: false
        type: boolean
        default: true
  workflow_run:
    workflows: ["build and publish"]
    types:
      - completed

env:
  GITHUB_OWNER: ${{ github.repository_owner }}
  IMAGE_NAME: chauhaidang/xq-fitness-write-service
  SERVICE_NAME: write-service

jobs:
  deploy:
    name: Deploy to App Platform
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.deploy == 'true') ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')
    permissions:
      contents: read
      packages: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DO_TOKEN }}

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq gettext-base

      - name: Determine image tag
        id: image-tag
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ] && [ -n "${{ github.event.inputs.image_tag }}" ]; then
            IMAGE_TAG="${{ github.event.inputs.image_tag }}"
          elif [ "${{ github.event_name }}" == "workflow_run" ]; then
            # Use the SHA from the triggering workflow
            IMAGE_TAG="${{ github.event.workflow_run.head_sha }}"
          elif [ "${{ github.ref }}" == "refs/heads/main" ]; then
            IMAGE_TAG="latest"
          else
            BRANCH_NAME=$(echo "${{ github.ref }}" | sed 's/refs\/heads\///')
            IMAGE_TAG="${BRANCH_NAME}-${GITHUB_SHA::8}"
          fi
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "✓ Using image tag: $IMAGE_TAG"
          echo "  Image: ghcr.io/${{ env.GITHUB_OWNER }}/${{ env.IMAGE_NAME }}:$IMAGE_TAG"

      - name: Provision database
        id: provision-db
        env:
          DO_TOKEN: ${{ secrets.DO_TOKEN }}
          REGION: ${{ secrets.REGION || 'sgp1' }}
          APP_NAME: ${{ secrets.APP_NAME || 'xq-fitness' }}
          APP_DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
        run: |
          # Provision database (idempotent - safe to run multiple times)
          chmod +x deploy/digitalocean/provision-db.sh
          cd deploy/digitalocean
          
          # Run provision-db.sh - it will create DB if needed or use existing
          # If user exists and password not provided, script will fail (expected)
          ./provision-db.sh 2>&1 | tee provision-output.log || {
            echo "⚠️  Provision script exited with error, checking if DB already exists..."
            # If script failed, try to get connection details from existing DB
          }
          
          # Get connection details by querying doctl (most reliable)
          DB_CLUSTER_NAME="${APP_NAME:-xq-fitness}-db"
          DB_CLUSTER_ID=$(doctl databases list --output json | jq -r '.[] | select(.name=="'"$DB_CLUSTER_NAME"'") | .id' | head -n1)
          
          if [ -z "$DB_CLUSTER_ID" ]; then
            echo "Error: Database cluster not found. Provision script may have failed."
            exit 1
          fi
          
          # Get connection details
          CONNECTION_JSON=$(doctl databases connection "$DB_CLUSTER_ID" --output json)
          
          # Handle both array and object formats (same logic as provision-db.sh)
          if echo "$CONNECTION_JSON" | jq -e 'type == "array"' >/dev/null 2>&1; then
            DB_HOST=$(echo "$CONNECTION_JSON" | jq -r '.[0].host // .[0].uri // empty')
            DB_PORT=$(echo "$CONNECTION_JSON" | jq -r '.[0].port // empty')
          else
            DB_HOST=$(echo "$CONNECTION_JSON" | jq -r '.host // .uri // empty')
            DB_PORT=$(echo "$CONNECTION_JSON" | jq -r '.port // empty')
          fi
          
          # If host is a URI, extract hostname from it
          if [[ "$DB_HOST" == *"@"* ]]; then
            DB_HOST=$(echo "$DB_HOST" | sed -E 's/.*@([^:]+).*/\1/')
          fi
          
          # Fallback: try to get connection string and parse it
          if [[ -z "$DB_HOST" ]] || [[ -z "$DB_PORT" ]]; then
            if echo "$CONNECTION_JSON" | jq -e 'type == "array"' >/dev/null 2>&1; then
              CONNECTION_STRING=$(echo "$CONNECTION_JSON" | jq -r '.[0].uri // .[0].connection_string // empty')
            else
              CONNECTION_STRING=$(echo "$CONNECTION_JSON" | jq -r '.uri // .connection_string // empty')
            fi
            if [[ -n "$CONNECTION_STRING" ]]; then
              DB_HOST=$(echo "$CONNECTION_STRING" | sed -E 's/.*@([^:]+):.*/\1/')
              DB_PORT=$(echo "$CONNECTION_STRING" | sed -E 's/.*:([0-9]+)\/.*/\1/')
            fi
          fi
          
          # Final fallback: extract from script output if still empty
          if [[ -z "$DB_HOST" ]] || [[ -z "$DB_PORT" ]]; then
            DB_HOST=$(grep -E "^  Host:" provision-output.log | awk '{print $2}' | tr -d '"' || echo "")
            DB_PORT=$(grep -E "^  Port:" provision-output.log | awk '{print $2}' | tr -d '"' || echo "")
          fi
          
          # Get database and user names (from script defaults or secrets)
          DB_NAME="${APP_DB_NAME:-xq_fitness}"
          DB_USER="${APP_DB_USER:-xq_app_user}"
          
          # Also try to extract from script output as fallback
          if [[ -z "$DB_NAME" ]]; then
            DB_NAME=$(grep -E "^  Database:" provision-output.log | awk '{print $2}' | tr -d '"' || echo "")
          fi
          if [[ -z "$DB_USER" ]]; then
            DB_USER=$(grep -E "^  User:" provision-output.log | awk '{print $2}' | tr -d '"' || echo "")
          fi
          
          # Use secrets as fallback
          DB_HOST="${DB_HOST:-${{ secrets.DB_HOST }}}"
          DB_PORT="${DB_PORT:-${{ secrets.DB_PORT }}}"
          DB_USER="${DB_USER:-${{ secrets.DB_USER }}}"
          DB_PASSWORD="${{ secrets.DB_PASSWORD }}"
          DB_NAME="${DB_NAME:-${{ secrets.DB_NAME }}}"
          
          if [ -z "$DB_HOST" ] || [ -z "$DB_PORT" ] || [ -z "$DB_USER" ] || [ -z "$DB_PASSWORD" ] || [ -z "$DB_NAME" ]; then
            echo "Error: Could not determine all database connection details"
            echo "DB_HOST: ${DB_HOST:-not set}"
            echo "DB_PORT: ${DB_PORT:-not set}"
            echo "DB_USER: ${DB_USER:-not set}"
            echo "DB_PASSWORD: ${DB_PASSWORD:+set (hidden)}"
            echo "DB_NAME: ${DB_NAME:-not set}"
            echo ""
            echo "Note: If this is the first run, ensure DB_PASSWORD secret is set after running provision-db.sh manually"
            exit 1
          fi
          
          # Output connection details for next step
          echo "db_host=$DB_HOST" >> $GITHUB_OUTPUT
          echo "db_port=$DB_PORT" >> $GITHUB_OUTPUT
          echo "db_user=$DB_USER" >> $GITHUB_OUTPUT
          echo "db_password=$DB_PASSWORD" >> $GITHUB_OUTPUT
          echo "db_name=$DB_NAME" >> $GITHUB_OUTPUT
          
          echo "✓ Database provisioned/verified"
          echo "  Host: $DB_HOST"
          echo "  Port: $DB_PORT"
          echo "  Database: $DB_NAME"
          echo "  User: $DB_USER"

      - name: Create or update App Platform app
        id: app-setup
        env:
          DO_TOKEN: ${{ secrets.DO_TOKEN }}
          REGION: ${{ secrets.REGION || 'sgp1' }}
          APP_NAME: ${{ secrets.APP_NAME || 'xq-fitness' }}
          GITHUB_OWNER: ${{ env.GITHUB_OWNER }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          IMAGE_TAG: ${{ steps.image-tag.outputs.image_tag }}
          GITHUB_REGISTRY_CREDENTIALS: ${{ env.GITHUB_OWNER }}:${{ secrets.GITHUB_PAT || secrets.GITHUB_TOKEN }}
          DB_HOST: ${{ steps.provision-db.outputs.db_host }}
          DB_PORT: ${{ steps.provision-db.outputs.db_port }}
          DB_USER: ${{ steps.provision-db.outputs.db_user }}
          DB_PASSWORD: ${{ steps.provision-db.outputs.db_password }}
          DB_NAME: ${{ steps.provision-db.outputs.db_name }}
        run: |
          # Use the deploy-service.sh script to create/update app
          chmod +x deploy/digitalocean/deploy-service.sh
          cd deploy/digitalocean
          ./deploy-service.sh ${{ env.SERVICE_NAME }}
          
          # Get APP_ID by querying doctl (most reliable method)
          APP_ID=$(doctl apps list --output json | jq -r '.[] | select(.spec.name=="'"${{ secrets.APP_NAME || 'xq-fitness' }}"'") | .id' | head -n1)
          
          if [ -z "$APP_ID" ]; then
            echo "Error: Could not determine APP_ID"
            exit 1
          fi
          
          echo "app_id=$APP_ID" >> $GITHUB_OUTPUT
          echo "✓ App ID: $APP_ID"

      - name: Deploy to App Platform
        uses: digitalocean/app_action/deploy@v2
        with:
          token: ${{ secrets.DO_TOKEN }}
          app_id: ${{ steps.app-setup.outputs.app_id }}

